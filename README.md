# Interactive Detective Visual Novel

Браузерная интерактивная визуальная новелла с авторским сценарием и встроенными мини-играми.  
Проект реализован на чистом HTML, CSS и JavaScript без использования фреймворков и ориентирован на десктопные браузеры.

---

## Архитектурный подход

Применена конфигурационно-ориентированная архитектура с централизованным управлением состоянием.

Основные принципы:

- Единый объект состояния приложения
- Декларативное описание сцен
- Одна точка рендера сцены
- Изолированные модули мини-игр
- Ручное управление жизненным циклом анимаций и таймеров
- Контролируемая загрузка ресурсов

Архитура не зависит от конкретной среды разработки и может работать на любом статическом хостинге.

---

## Структура проекта

/project-root
│
├── index.html        // Разметка приложения
├── main.css          // Стили, анимации, оверлеи
├── script.js         // Логика сцен, состояние, мини-игры
├── /assets
│   ├── backgrounds   // Фоновые изображения
│   ├── intro         // Интро-изображения
│   ├── ui            // Кнопки, интерфейсные элементы
│   └── effects       // Эффекты и графические элементы

Проект не требует сборки. Запуск осуществляется напрямую через `index.html`.

---

## Управление состоянием

Всё текущее состояние хранится в одном объекте `state`.

Пример структуры:

```js
state = {
  currentScene: null,
  history: [],
  textIndex: 0,
  isTextStarted: false,
  waitingForChoice: false,
  choiceReady: false,

  sleepGameCompleted: false,
  dogsGameCompleted: false,
  evidenceGameCompleted: false,

  introTimeout: null,
  introFadeTimeout: null,
  choiceTimeout: null
}
```

Назначение:

- Контроль текущей сцены
- История переходов
- Индексация текста
- Блокировка повторных событий
- Управление таймерами
- Флаги завершения мини-игр

Подход обеспечивает предсказуемость поведения без применения сторонних state-management решений.

---

## Система сцен

Все сцены описываются в объекте `scenes`.

Пример:

```js
const scenes = {
  scene_1: {
    background: "assets/backgrounds/scene1.jpg",
    text: [...],
    next: "scene_2",
    minigame: null,
    particles: null,
    introImage: null
  }
}
```

Поддерживаемые свойства:

- `background`
- `text`
- `next`
- `type` (например, "ending")
- `minigame`
- `particles`
- `introImage`
- `showDuration`

Такой подход позволяет масштабировать повествование без изменения основной логики приложения.

---

## Рендеринг сцены

Ключевая функция: `renderScene(sceneId, fromHistory = false)`

Основные задачи:

- Очистка всех таймеров
- Сброс UI-состояния
- Обновление `state.currentScene`
- Предзагрузка фонового изображения
- Контроль затемнения (fade)
- Запуск мини-игры при необходимости
- Инициализация текста

---

## Механизм загрузки фона

Для исключения визуальных скачков реализован ручной механизм загрузки:

1. Активируется чёрный overlay (fade-layer).
2. Предыдущий фон удаляется.
3. Создаётся новый `Image()`.
4. После события `onload` применяется `backgroundImage`.
5. Overlay плавно скрывается.

Преимущества:

- Отсутствует «мигание» старого фона.
- Нет появления пустого белого экрана.
- Переходы остаются плавными даже при медленном соединении.

---

## Система переходов (Fade)

Переходы реализованы через отдельный DOM-слой:

- Затемняющий элемент с управлением классом `.active`
- CSS transition отвечает за плавность
- JavaScript отвечает только за переключение состояний

Такой подход разделяет визуальную часть и логику.

---

## Отображение текста

Текст сцены отображается по нажатию `Space`.

Используются:

- `textIndex` — текущая строка
- Флаги блокировки
- Раздельные текстовые контейнеры (нарратив и диалог)

Система защищена от:

- двойных нажатий
- конфликтов выбора
- параллельных переходов

---

## Мини-игры

Все мини-игры реализованы по единой архитектурной схеме:

1. В конфигурации сцены указан `minigame`.
2. `renderScene` определяет необходимость запуска.
3. Запускается функция конкретной игры.
4. При победе устанавливается флаг в `state`.
5. При проигрыше отображаются кнопки повторной попытки.
6. После двух поражений появляется кнопка пропуска.

Каждая мини-игра полностью изолирована по логике.

---

### Мини-игра "Не уснуть"

Использует:

- requestAnimationFrame
- накопление затемнения
- управление скоростью усложнения

Основные параметры:

```js
const GAME_DURATION = 40000;
let darkeningSpeed = 0.002;
const DARKEN_INCREMENT = 0.15;
```

Проигрыш:

- веки полностью сомкнуты

Победа:

- игрок продержался заданное время

---

### Мини-игра с собаками

Использует:

- три независимых состояния ярости
- кликабельные области
- анимационное изменение размеров круга

Настройки:

```js
const DOGS_GAME_DURATION = 20000;
const RAGE_INCREASE_SPEED = 0.015;
const RAGE_DECREASE_ON_CLICK = 0.25;
const MAX_RAGE = 1;
```

Каждый круг позиционируется и настраивается индивидуально.

---

### Мини-игра с осмотром улик

Принцип:

- Кликабельные PNG-оверлеи
- Подсчёт найденных элементов
- Переход после полного осмотра

Реализация основана на обработчиках событий и счётчиках состояния.

---

## Анимации и эффекты

### Частицы

- Генерация через requestAnimationFrame
- Плавное исчезновение
- Контроль количества

### Аура

- PNG-изображение
- CSS-анимация вращения
- Центрирование через позиционирование

В проекте отсутствуют сторонние анимационные библиотеки.

---

## Управление таймерами

Перед сменой сцены:

- очищаются все setTimeout
- отменяются анимационные циклы
- удаляются обработчики событий

Это предотвращает:

- утечки
- повторные вызовы
- конфликт логики

---

## Производительность

Учитывается:

- минимизация пересчётов стилей
- ручной контроль жизненного цикла
- разделение анимаций и логики
- работа без постоянных перерасчётов layout

Проект рассчитан на современные десктопные браузеры.

---

## Расширяемость

Добавление новой сцены:

1. Добавить объект в `scenes`
2. Добавить необходимые изображения
3. При необходимости подключить мини-игру

Архитектура не требует рефакторинга при расширении.

---

## Развёртывание

Приложение является статическим.

Поддерживаемые платформы:

- GitHub Pages
- Netlify
- Vercel
- любой статический хостинг

Бэкенд отсутствует. Серверная часть не требуется.

---

## Концепция и художественная ценность

### Сценарий

Сценарий написан полностью автором проекта.  
История выстроена как последовательное погружение в детективное расследование с постепенным раскрытием деталей, психологическим напряжением и акцентом на атмосферу.

Структура включает:

- более 90 отдельных сцен
- постепенное раскрытие улик и мотивов
- игровые эпизоды, органично встроенные в сюжет
- чередование статичного повествования и динамических интерактивных моментов

---

### Визуальная среда

Каждая сцена имеет собственный фон.

Все реалистичные визуальные элементы основаны на реальных местах, объектах и пространствах. Изображения были:

- отобраны по смысловому соответствию сцене
- скорректированы композиционно
- доработаны или стилистически изменены с применением инструментов ИИ

Таким образом, визуальный слой не является абстрактным, а опирается на узнаваемую материальную реальность, что усиливает ощущение подлинности происходящего и создаёт эффект погружения.

---

### Интерфейс

Все элементы пользовательского интерфейса были спроектированы и отрисованы автором в Figma.  

К ним относятся:

- кнопки перезапуска и пропуска мини-игр
- элементы подсказок
- визуальные индикаторы
- оверлеи и вспомогательные графические компоненты

Интерфейс не заимствован из сторонних библиотек и не использует готовые UI-наборы. Он создавался как часть художественной системы проекта, а не как универсальный шаблон.

---

## Потенциальные технические улучшения

Возможные направления развития:

- сохранение прогресса через localStorage
- глобальный preload всех изображений
- адаптивная версия под мобильные устройства
- подключение аудио
- выделение мини-игр в отдельные модули
- формализация конечного автомата состояний


Здесь конфликт передаётся через управление несколькими состояниями одновременно.

---
